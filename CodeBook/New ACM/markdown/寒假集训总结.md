> # Day 1
1.字典树学习
---
### problem A 字典树前缀问题，先使用指针法构造0/1二叉树求解，140MS，内存4M+,汗@_@。群里各种prefect字典树，后来才得知可以数组模拟字典树，还有双数组模拟，于是problem A 成功46MS。  
附上字典树模板   ：
``` C++
int node[N][26]={0};        
int sz=1;                 
int val[N];      
void insert(char *str)  
{  
    int p=0,c;
    for(int i=0;str[i]!='\0';i++)  
    {  
        c=str[i]-'a';  
        if(node[p][c] == 0)  
            node[p][c] = sz++;  
        p =node[p][c];  
        val[p]++;          
    }  
}  
int Query(char *str)  
{  
    int p = 0;
    for(int i=0;str[i]!='\0';i++)  
    {  
        int c=str[i]-'a';  
        if(!node[p][c])  
            return 0;  
        p=node[p][c];  
    }  
    return  val[p];  
}  
```
### problem B





> ### 1月25日  

># 贪心算法学习
说起来别不信今天我这个acmer正式开始学贪心算法了，原因在于起初为了解决问题看博客匆忙学过，没有总结今天到了贪心的应用竟然没看出来，羞qwq.
>先说贪心法的应用：
1.哈夫曼编码
2.0-1背包问题
3.磁盘文件的存储
4.生产调度问题
5.信息查询
>贪心的几个基本集合及函数
1.候选集合C 
2.解集合  
3.solution 函数  ——检查解集合S是否构成问题的完整解。
4. select函数 ——它指出哪个候选对象最有希望构成问题的解，选择函数通常和目标函数有关
5.feasible 函数 check 候选对象是否可行，即解集合扩展后是否满足约束条件。
>重点来了 怎么知道一个问题可以使用贪心来解/因贪心有两个重要的性质:
1.贪心选择性质 ——也就是局部最优是可行的
2.最优子结构性——及子问题的最优解可以推出整体的最优或者说是当一个问题的最优解包含其子问题的最优解
>提一下子问题概念：
假设为了解决某一优化问题，需要依次做出n个决策D1，D2,...,Dn,对于任何一个整数k,1<k<n,以Dk作为问题的初识状态，来进行以后的决策，这样的问题就是成为原问题的子问题。

第一应用 ：哈夫曼编码
需要的基础知识：二叉树，一点ADT知识。
>关于二叉树的必备知识(binary tree) 






