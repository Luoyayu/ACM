2017年3月29日18点37分
KMP算法及KMP扩展及有限状态机及AC自动机理解
#part 1：
##重点理解next[]形成与利用
问题:有文本串S，模式串P，询问P在S中出现的首位置，出现次数等。
#BF解法：i = 0, j = 0;
while  i<lens && j<lenp:
    if(s[i]==p[j])
        i++,j++;
    else i = i - j + 1, j = 0; //失配则 i , j 回溯
    if(j==lenp)
        return i-j;
    else
        return no found!
#利用部分匹配信息修优化BF算法
KMP算法流程
假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置
1.如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；
2.如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。
  此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。
  换言之，当失配时，模式串向右移动的位数：失配字符pos - 失配字符next []，
  即移动的实际位数为：j - next[j]，且此值大于等于1。
Next[]实际意义：代表当前字符之前中有多大长度相同的前后缀。
如果next[j]==-1/0 则跳到模式串的开头字符，若next[j]=k>0则模式串下次匹配跳到j之前的k个字符处
在模式串p中已知Next[0...j] 求解Next[j+1]
对与p前j+个字符
p0,pk-1,pk-1,pk,pk+1,pj-k,pj-1,pj,pj+1 已知p0,pk-1==pj-k,j-1 
如果