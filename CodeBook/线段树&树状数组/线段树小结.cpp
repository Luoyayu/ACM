<----线段树小结：  (2017年3月22日18点44分)----->
<基本概念>：线段树是一棵二叉树，每个节点保存区间信息，父节代表的区间为左右节点代表的区间的和
<基本思想与结构>:对于非叶节点所表示的节点[a,b],其左孩子节点区间是[a,(a+b)>>1],右孩子[(a+b)>>1|1,b] 对于偶数a|1=a+1,对于奇数a|1=a;

Note:节点数开为tree[maxn<<2] 一般所需maxn*3,确保叶节点保存。
#define Ls i<<1
#define Rs i<<1|1
#define lson l, M,Ls
#define rson M+1,r,Rs
<解题模型>：一个问题，如果能转换成一些连续点的修改或统计，就可以考虑用线段树解决
首先确定目标信息和点信息，然后将目标信息转换成区间信息
相邻的区间的信息可以被合并成两个区间的并区间的信息
int tree[maxn<<2]//线段树需要维护的信息
void push_up(int i) {}//维护节点信息，把当前节点的信息更新到父节点
void pushdown(int i,int num) //num=(r-l+1)>>1+1
{
    int &tmp=Add[i];
    if(tmp)
    {
        Add[Ls]+=tmp,Add[Rs]+=tmp;//以求sum示例打标记
        //修改子节点的sum使之与对应的Add相应
        sum[Ls]+=Add[i]*(num-num>>1);
        sum[Rs]+=Add[i]*(num>>1);
        tmp=0;//清除本节点标记
    }
}//把当前节点的信息更新给孩子节点，用作lazy延迟更新
void build(int i,int l,int r)//初始化建树
{
    if(l==r) {} //get data OR memset(Data) 递归出口到达叶节点
    int M=(l+r)>>1;
    build(lson),build(rson),push_up(i);//递归建树维护信息
}                   //操作区间             当前节点区间
void update(int ql,int qr,int val,int l,int r,int i){}//更新区间
{
    if(ql<=l&&qr>=r){}//如果[l,r]区间完全在操作区间[ql,lr]内
        pushdown(i,r-l+1);//下推标记
    int M=(l+r)>>1;
    //判断左右子树更[ql,qr] 是否有无交集，有交集则递归，有些题在无交集时也需要处理'
    if(ql<=M) {}
    if(qr>M) {}
    push_up(i);//更新信息
}
int query(int ql;int qr,int l,int r,int i)
{
    if(ql<=l&&qr>=r) {}
    pushdown(i,r-l+1);
    int res=0;
    int M=(l+r)>>1;
    if(ql<=M) {} 
    if(qr>M) {}
    return res;
}
<基本操作>
1->                         <---线段树的单点修改--->
        >每个节点表示一段线段,存储自己对应的区间的统计信息
        >修改一个点影响每层的一个点及父亲节点，修改复杂度O(log(n);
        >线段树的区间查询：定理n>=3时线段树[1,N]最多将分解出2|_ log[2](n-1)_|个子区间
           -故查询复杂度：O(log(n))
2->                         <---线段树的区间(成段)修改-->
        >线段树的区间修改时将区间分成子区间并给每个节点添加lazy标记，也成懒惰标记或延迟标记
           -标记的含义 ：本节点的统计信息已经根据标记更新过了，但是本节点的左右子节点仍需要更新。使得更新延迟到下次需要更新或查询时候/
                 待下次查询或更新时，如果遇到节点P,并需要考虑其子节点时，看看这个节点p有没有标记，如果有就要按照标记修改其子节点的信息，
                 并且给子节点打上相同的标记，同时消除P的标记。
           -向下延迟更新，但是向上是显示修改后的信息！
           -重点考虑标记间的互相影响，需要在每递归到一个区间，首先pushdown下推标记，然后再打上新的标记
        >标记---1)相对标记：标记间可以共存例如+a，更打标记的时间顺序无关。
                    -2)绝对标记：标记间的顺序直接影响结果例如<set>
                    -3)总之在区间修改时下推标记很必要
3.->                               <---区间合并--->
        
4.->                                 <---扫描线--->
