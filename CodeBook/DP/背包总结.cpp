//那些年我们背过的包
//01背包 完全背包 多重背包 二维费用背包

//<**************ZeroOnePack*****************>
//有N件物品和一个容量为V的背包.(每种物品均只有一件)第i件费用是c[i],价值w[i].
//求解将哪些物品装入背包可使价值总和最大
//dp[i][v] 表示前i件物品恰放入一个容量为v的背包可获得的最大价值
转移方程:dp[i][v]=max(dp[i-1][v],dp[i-1][v-c[i]]+w[i])
//空间优化: dp[v] 表示把前i件物品放进容量为V的背包取得的价值
if(恰好装满背包) dp[0]=0,clear(dp+1,-oo); 
if(不必装满) clear(dp,-oo);
//有前一个状态逆推，由当前状态决定正推
for(int i=1;i<=N;i++)
    for(int v=V;v>=c[i];v--)
        dp[v]=max(dp[v],dp[v-c[i]]+w[i]);//每一次决策都去和上一步的最优状态比较


//<**************CompletePack*****************>
//有N种物品和一个容量为V的背包(每种物品都有无限件)第i种物品的费用是c[i]，价值是w[i]。
//求解将哪些物品装入背包可使这些物品的cost总和不超过V，且价值总和最大。
转移方程:dp[i][v]=max(dp[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v)
//空间优化:
for(int i=1;i<=N;i++)
    for(int v=c[i];v<=V;v++)
        dp[v]=max(dp[v],dp[v-c[i]]+w[i]);



//<*******************************>

