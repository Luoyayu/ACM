back to the beginning
>1.Recursion（how to new a Recursion）
    >>0.definition
      >递归（recursion）分两步，递和归，递是递推；归是回归。
	  >递归需要有边界条件、递归前进段和递归返回段。
	   当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
	  >尾递归:函数调用出现在调用者函数的尾部,把当前的运算结果放在参数里传给下层函数
    >>1.Why use the Recursion
	  >缩小问题规模
	  >create无限循环体
    >>2.Recursion 归纳法理解
      >Recursion 模型基于数学上的归纳法
	
	
	
	
	
	
	
	
>2.DP入门学习及优化及基本模型 
	>>动态规划几个特性：
		>“最有子结构 ”——子问题最优时母问题通过优化选择时一定最优，
		>“子问题重叠”——母问题在本质上和子问题是同一个问题的情况
		>“边界”——子问题在一定情况下不需要再提出子问题的情况
		>“子问题独立”——当前被选择的子问题两两互不影响 
	>>动态规划的转移方程 即用来描述最优子结构的过程 
	>>动态规划思考问题：基于问题过程的思考，过程开始于事件过程的最后一步，即问题考虑的最后一步。
						在解决母问题时需要构造一个过程。
	>>优化一：采取带备忘的自顶向下法（top-down with memoization）
		  二： 采用自底向上法 （bottom-up method）
		  
		  
		  
		  
	>>重温几个动态规划例子：
	1)  找硬币问题
		描述就不赘叙了。有零钱v[0~n]={1,3,5,···}各若干;需找值为N￥，求解找零最少硬币数d
		>定义状态：d[i] 表示求总和为i的最少硬币数量
		>思路
			假设d[1~i-1]全部求出，那么d[i]=min(d[j]+1) if(i-j)∈v
									   0≤j≤i						
			采取优化一
	2)锯钢条问题(算法导论)
		已知锯成i米的钢条售价N[i]元，给出n求最大获利
		
		
		
>>搜索 (DFS&BFS)
 >DFS:Depth-First Search
 
						
	
	
	
>>最小生成树 prime算法总结
	设有联通